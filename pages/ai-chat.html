<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ù…Ø­Ø§Ø¯Ø«Ø© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„Ø´Ø®ØµÙŠ</title>
  <style>
    body { font-family: system-ui, sans-serif; background:#0b1220; color:#e8edf7; margin:0; }
    header { padding:12px 16px; border-bottom:1px solid rgba(255,255,255,.08); display:flex; align-items:center; gap:12px; }
    .status { font-size:12px; opacity:.8; }
    .wrap { max-width: 900px; margin: 0 auto; padding: 16px; }
    .msgs { display:flex; flex-direction:column; gap:10px; padding-bottom: 80px; }
    .msg { padding:10px 12px; border-radius:10px; max-width: 80%; line-height:1.5; }
    .user { background: rgba(80,120,255,.15); align-self:flex-end; border:1px solid rgba(80,120,255,.35); }
    .ai { background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); }
    .composer { position:fixed; bottom:0; left:0; right:0; background:#0b1220; border-top:1px solid rgba(255,255,255,.08); padding:10px 16px; display:flex; gap:8px; }
    textarea { flex:1; resize:vertical; min-height:44px; max-height:160px; padding:10px; border-radius:10px; border:1px solid rgba(255,255,255,.15); background:#0f172a; color:#e8edf7; }
    button { padding:10px 14px; border-radius:10px; border:1px solid rgba(255,255,255,.22); background:#17203a; color:#fff; cursor:pointer; }
    button:disabled { opacity:.5; cursor:not-allowed; }
  </style>
</head>
<body>
  <header>
    <div>ğŸ¤ Ù…Ø³Ø§Ø¹Ø¯ Ù…Ø­Ù…Ø¯</div>
    <div class="status" id="aiStatus">ÙŠØªØµÙ„ Ø¨Ø§Ù„Ø®Ø§Ø¯Ù…â€¦</div>
    <div style="margin-inline-start:auto; display:flex; align-items:center; gap:6px; font-size:12px; opacity:.9;">
      <label style="display:flex; align-items:center; gap:6px; cursor:pointer;">
        <input type="checkbox" id="streamToggle" checked />
        <span>Ø¨Ø« Ù…Ø¨Ø§Ø´Ø±</span>
      </label>
    </div>
  </header>
  <div class="wrap">
    <div class="msgs" id="msgs"></div>
  </div>
  <div class="composer">
    <textarea id="prompt" placeholder="Ø§ÙƒØªØ¨ Ø±Ø³Ø§Ù„ØªÙƒâ€¦"></textarea>
    <button id="send">Ø¥Ø±Ø³Ø§Ù„</button>
  </div>

  <script src="../js/dev-api-detect.js"></script>
  <script src="../js/market-common.js"></script>
  <script>
    (function(){
      const msgs = document.getElementById('msgs');
      const promptEl = document.getElementById('prompt');
      const sendBtn = document.getElementById('send');
      const statusEl = document.getElementById('aiStatus');
      const streamToggle = document.getElementById('streamToggle');
      const history = [];
      let sessionId = 'web-'+Math.random().toString(36).slice(2,9);

      function add(role, text){
        const d = document.createElement('div'); d.className = 'msg ' + (role==='user'?'user':'ai'); d.textContent = text; msgs.appendChild(d); d.scrollIntoView({ behavior: 'smooth', block: 'end' });
      }

      async function getBase(){
        try {
          if (window.Market && Market.Common && typeof Market.Common.whenReady==='function') { await Market.Common.whenReady(); }
          const base = (Market && Market.Common && Market.Common.getApiBase && Market.Common.getApiBase()) || (Market && Market.Common && Market.Common.apiBase) || '';
          if (!base) return '';
          // If base already has /api strip trailing /api to avoid duplication
          return base.replace(/\/?api\/?$/i,'');
        } catch(_) { return ''; }
      }

      async function send(){
        const txt = (promptEl.value || '').trim();
        if(!txt) return; sendBtn.disabled = true; promptEl.value = '';
        add('user', txt); history.push({ role:'user', content: txt });
        const base = await getBase();
        const useStream = !!streamToggle.checked;
        const url = (base || '') + (useStream ? '/api/ai/chat/stream' : '/api/ai/chat');
        const t0 = performance.now();
        try {
          if(useStream){
            const r = await fetch(url, { method:'POST', headers:{ 'Content-Type':'application/json', 'Accept':'text/event-stream' }, body: JSON.stringify({ prompt: txt, history: history.slice(-8), sessionId }) });
            if(!r.ok){ throw new Error('request_failed'); }
            const reader = r.body.getReader();
            const decoder = new TextDecoder('utf-8');
            let buf=''; let current='';
            const live = document.createElement('div'); live.className='msg ai'; live.textContent=''; msgs.appendChild(live); live.scrollIntoView({ behavior:'smooth', block:'end' });
            for(;;){
              const { value, done } = await reader.read();
              if(done) break;
              buf += decoder.decode(value, { stream:true });
              let idx;
              while((idx = buf.indexOf('\n\n')) !== -1){
                const chunk = buf.slice(0, idx).trim();
                buf = buf.slice(idx+2);
                if(!chunk) continue;
                const lines = chunk.split('\n');
                for(const line of lines){
                  if(line.startsWith('data: ')){
                    const data = line.slice(6);
                    if(data === '[DONE]') { break; }
                    try {
                      const j = JSON.parse(data);
                      if(j && typeof j.delta === 'string'){ current += j.delta; live.textContent = current; }
                      if(j && j.ok){ const latency = Math.round(performance.now()-t0); statusEl.textContent = `Ù…ØªØµÙ„ â€¢ ${latency}ms`; }
                    } catch(_){ }
                  }
                }
              }
            }
            history.push({ role:'assistant', content: current });
          } else {
            const r = await fetch(url, { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify({ prompt: txt, history: history.slice(-8), sessionId }) });
            const j = await r.json();
            if(!r.ok || !j.ok){ throw new Error(j && j.error || 'request_failed'); }
            const latency = Math.round(performance.now()-t0);
            statusEl.textContent = `Ù…ØªØµÙ„ â€¢ ${latency}ms`;
            add('assistant', j.reply || ''); history.push({ role:'assistant', content: j.reply || '' });
          }
        } catch(e){ statusEl.textContent = 'ØªØ¹Ø°Ø± Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯'; add('assistant', 'âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£: ' + (e && e.message || e)); }
        finally { sendBtn.disabled = false; }
      }

      sendBtn.addEventListener('click', send);
      promptEl.addEventListener('keydown', (e)=>{ if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); send(); }});

      (async function init(){
        try {
          const base = await getBase();
          if(base){ statusEl.textContent = 'Ø¬Ø§Ù‡Ø²'; } else { statusEl.textContent = 'Ù‚Ø¯ ÙŠØªØ·Ù„Ø¨ Ø¥Ø¹Ø¯Ø§Ø¯ API Base'; }
        } catch(_){ statusEl.textContent = '...'; }
      })();
    })();
  </script>
</body>
</html>
